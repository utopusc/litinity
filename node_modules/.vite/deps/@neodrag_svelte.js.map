{
  "version": 3,
  "sources": ["../../@neodrag/svelte/dist/index.js"],
  "sourcesContent": ["// ../core/dist/index.js\nvar DEFAULT_RECOMPUTE_BOUNDS = {\n  dragStart: true\n};\nvar DEFAULT_DRAG_THRESHOLD = {\n  delay: 0,\n  distance: 3\n  /* DISTANCE */\n};\nfunction draggable(node, options = {}) {\n  let {\n    bounds,\n    axis = \"both\",\n    gpuAcceleration = true,\n    legacyTranslate = false,\n    transform,\n    applyUserSelectHack = true,\n    disabled = false,\n    ignoreMultitouch = false,\n    recomputeBounds = DEFAULT_RECOMPUTE_BOUNDS,\n    grid,\n    threshold = DEFAULT_DRAG_THRESHOLD,\n    position,\n    cancel,\n    handle,\n    defaultClass = \"neodrag\",\n    defaultClassDragging = \"neodrag-dragging\",\n    defaultClassDragged = \"neodrag-dragged\",\n    defaultPosition = { x: 0, y: 0 },\n    onDragStart,\n    onDrag,\n    onDragEnd\n  } = options;\n  let is_interacting = false;\n  let is_dragging = false;\n  let start_time = 0;\n  let meets_time_threshold = false;\n  let meets_distance_threshold = false;\n  let translate_x = 0, translate_y = 0;\n  let initial_x = 0, initial_y = 0;\n  let client_to_node_offsetX = 0, client_to_node_offsetY = 0;\n  let { x: x_offset, y: y_offset } = position ? { x: position?.x ?? 0, y: position?.y ?? 0 } : defaultPosition;\n  set_translate(x_offset, y_offset);\n  let can_move_in_x;\n  let can_move_in_y;\n  let body_original_user_select_val = \"\";\n  let computed_bounds;\n  let node_rect;\n  let drag_els;\n  let cancel_els;\n  let currently_dragged_el;\n  let is_controlled = !!position;\n  recomputeBounds = { ...DEFAULT_RECOMPUTE_BOUNDS, ...recomputeBounds };\n  threshold = { ...DEFAULT_DRAG_THRESHOLD, ...threshold ?? {} };\n  let active_pointers = /* @__PURE__ */ new Set();\n  function try_start_drag() {\n    if (is_interacting && !is_dragging && meets_distance_threshold && meets_time_threshold && currently_dragged_el) {\n      is_dragging = true;\n      fire_svelte_drag_start_event();\n      node_class_list.add(defaultClassDragging);\n      if (applyUserSelectHack) {\n        body_original_user_select_val = body_style.userSelect;\n        body_style.userSelect = \"none\";\n      }\n    }\n  }\n  function reset_state() {\n    is_dragging = false;\n    meets_time_threshold = false;\n    meets_distance_threshold = false;\n  }\n  const body_style = document.body.style;\n  const node_class_list = node.classList;\n  function set_translate(x_pos = translate_x, y_pos = translate_y) {\n    if (!transform) {\n      if (legacyTranslate) {\n        let common = `${+x_pos}px, ${+y_pos}px`;\n        return set_style(\n          node,\n          \"transform\",\n          gpuAcceleration ? `translate3d(${common}, 0)` : `translate(${common})`\n        );\n      }\n      return set_style(node, \"translate\", `${+x_pos}px ${+y_pos}px`);\n    }\n    const transform_called = transform({ offsetX: x_pos, offsetY: y_pos, rootNode: node });\n    if (is_string(transform_called)) {\n      set_style(node, \"transform\", transform_called);\n    }\n  }\n  function get_event_data() {\n    return {\n      offsetX: translate_x,\n      offsetY: translate_y,\n      rootNode: node,\n      currentNode: currently_dragged_el\n    };\n  }\n  function call_event(eventName, fn) {\n    const data = get_event_data();\n    node.dispatchEvent(new CustomEvent(eventName, { detail: data }));\n    fn?.(data);\n  }\n  function fire_svelte_drag_start_event() {\n    call_event(\"neodrag:start\", onDragStart);\n  }\n  function fire_svelte_drag_end_event() {\n    call_event(\"neodrag:end\", onDragEnd);\n  }\n  function fire_svelte_drag_event() {\n    call_event(\"neodrag\", onDrag);\n  }\n  const listen = addEventListener;\n  const controller = new AbortController();\n  const event_options = { signal: controller.signal, capture: false };\n  set_style(node, \"touch-action\", \"none\");\n  listen(\n    \"pointerdown\",\n    (e) => {\n      if (disabled)\n        return;\n      if (e.button === 2)\n        return;\n      active_pointers.add(e.pointerId);\n      if (ignoreMultitouch && active_pointers.size > 1)\n        return e.preventDefault();\n      if (recomputeBounds.dragStart)\n        computed_bounds = compute_bound_rect(bounds, node);\n      if (is_string(handle) && is_string(cancel) && handle === cancel)\n        throw new Error(\"`handle` selector can't be same as `cancel` selector\");\n      node_class_list.add(defaultClass);\n      drag_els = get_handle_els(handle, node);\n      cancel_els = get_cancel_elements(cancel, node);\n      can_move_in_x = /(both|x)/.test(axis);\n      can_move_in_y = /(both|y)/.test(axis);\n      if (cancel_element_contains(cancel_els, drag_els))\n        throw new Error(\n          \"Element being dragged can't be a child of the element on which `cancel` is applied\"\n        );\n      const event_target = e.composedPath()[0];\n      if (drag_els.some((el) => el.contains(event_target) || el.shadowRoot?.contains(event_target)) && !cancel_element_contains(cancel_els, [event_target])) {\n        currently_dragged_el = drag_els.length === 1 ? node : drag_els.find((el) => el.contains(event_target));\n        is_interacting = true;\n        start_time = Date.now();\n        if (!threshold.delay) {\n          meets_time_threshold = true;\n        }\n      } else\n        return;\n      node_rect = node.getBoundingClientRect();\n      const { clientX, clientY } = e;\n      const inverse_scale = calculate_inverse_scale();\n      if (can_move_in_x)\n        initial_x = clientX - x_offset / inverse_scale;\n      if (can_move_in_y)\n        initial_y = clientY - y_offset / inverse_scale;\n      if (computed_bounds) {\n        client_to_node_offsetX = clientX - node_rect.left;\n        client_to_node_offsetY = clientY - node_rect.top;\n      }\n    },\n    event_options\n  );\n  listen(\n    \"pointermove\",\n    (e) => {\n      if (!is_interacting || ignoreMultitouch && active_pointers.size > 1)\n        return;\n      if (!is_dragging) {\n        if (!meets_time_threshold) {\n          const elapsed = Date.now() - start_time;\n          if (elapsed >= threshold.delay) {\n            meets_time_threshold = true;\n            try_start_drag();\n          }\n        }\n        if (!meets_distance_threshold) {\n          const delta_x = e.clientX - initial_x;\n          const delta_y = e.clientY - initial_y;\n          const distance = Math.sqrt(delta_x ** 2 + delta_y ** 2);\n          if (distance >= threshold.distance) {\n            meets_distance_threshold = true;\n            try_start_drag();\n          }\n        }\n        if (!is_dragging)\n          return;\n      }\n      if (recomputeBounds.drag)\n        computed_bounds = compute_bound_rect(bounds, node);\n      e.preventDefault();\n      node_rect = node.getBoundingClientRect();\n      let final_x = e.clientX, final_y = e.clientY;\n      const inverse_scale = calculate_inverse_scale();\n      if (computed_bounds) {\n        const virtual_client_bounds = {\n          left: computed_bounds.left + client_to_node_offsetX,\n          top: computed_bounds.top + client_to_node_offsetY,\n          right: computed_bounds.right + client_to_node_offsetX - node_rect.width,\n          bottom: computed_bounds.bottom + client_to_node_offsetY - node_rect.height\n        };\n        final_x = clamp(final_x, virtual_client_bounds.left, virtual_client_bounds.right);\n        final_y = clamp(final_y, virtual_client_bounds.top, virtual_client_bounds.bottom);\n      }\n      if (Array.isArray(grid)) {\n        let [x_snap, y_snap] = grid;\n        if (isNaN(+x_snap) || x_snap < 0)\n          throw new Error(\"1st argument of `grid` must be a valid positive number\");\n        if (isNaN(+y_snap) || y_snap < 0)\n          throw new Error(\"2nd argument of `grid` must be a valid positive number\");\n        let delta_x = final_x - initial_x, delta_y = final_y - initial_y;\n        [delta_x, delta_y] = snap_to_grid(\n          [x_snap / inverse_scale, y_snap / inverse_scale],\n          delta_x,\n          delta_y\n        );\n        final_x = initial_x + delta_x;\n        final_y = initial_y + delta_y;\n      }\n      if (can_move_in_x)\n        translate_x = Math.round((final_x - initial_x) * inverse_scale);\n      if (can_move_in_y)\n        translate_y = Math.round((final_y - initial_y) * inverse_scale);\n      x_offset = translate_x;\n      y_offset = translate_y;\n      fire_svelte_drag_event();\n      set_translate();\n    },\n    event_options\n  );\n  listen(\n    \"pointerup\",\n    (e) => {\n      active_pointers.delete(e.pointerId);\n      if (!is_interacting)\n        return;\n      if (is_dragging) {\n        listen(\"click\", (e2) => e2.stopPropagation(), {\n          once: true,\n          signal: controller.signal,\n          capture: true\n        });\n        if (recomputeBounds.dragEnd)\n          computed_bounds = compute_bound_rect(bounds, node);\n        node_class_list.remove(defaultClassDragging);\n        node_class_list.add(defaultClassDragged);\n        if (applyUserSelectHack)\n          body_style.userSelect = body_original_user_select_val;\n        fire_svelte_drag_end_event();\n        if (can_move_in_x)\n          initial_x = translate_x;\n        if (can_move_in_y)\n          initial_y = translate_y;\n      }\n      is_interacting = false;\n      reset_state();\n    },\n    event_options\n  );\n  function calculate_inverse_scale() {\n    let inverse_scale = node.offsetWidth / node_rect.width;\n    if (isNaN(inverse_scale))\n      inverse_scale = 1;\n    return inverse_scale;\n  }\n  return {\n    destroy: () => controller.abort(),\n    update: (options2) => {\n      axis = options2.axis || \"both\";\n      disabled = options2.disabled ?? false;\n      ignoreMultitouch = options2.ignoreMultitouch ?? false;\n      handle = options2.handle;\n      bounds = options2.bounds;\n      recomputeBounds = options2.recomputeBounds ?? DEFAULT_RECOMPUTE_BOUNDS;\n      cancel = options2.cancel;\n      applyUserSelectHack = options2.applyUserSelectHack ?? true;\n      grid = options2.grid;\n      gpuAcceleration = options2.gpuAcceleration ?? true;\n      legacyTranslate = options2.legacyTranslate ?? true;\n      transform = options2.transform;\n      threshold = { ...DEFAULT_DRAG_THRESHOLD, ...options2.threshold ?? {} };\n      const dragged = node_class_list.contains(defaultClassDragged);\n      node_class_list.remove(defaultClass, defaultClassDragged);\n      defaultClass = options2.defaultClass ?? \"neodrag\";\n      defaultClassDragging = options2.defaultClassDragging ?? \"neodrag-dragging\";\n      defaultClassDragged = options2.defaultClassDragged ?? \"neodrag-dragged\";\n      node_class_list.add(defaultClass);\n      if (dragged)\n        node_class_list.add(defaultClassDragged);\n      if (is_controlled) {\n        x_offset = translate_x = options2.position?.x ?? translate_x;\n        y_offset = translate_y = options2.position?.y ?? translate_y;\n        set_translate();\n      }\n    }\n  };\n}\nvar clamp = (val, min, max) => Math.min(Math.max(val, min), max);\nvar is_string = (val) => typeof val === \"string\";\nvar snap_to_grid = ([x_snap, y_snap], pending_x, pending_y) => {\n  const calc = (val, snap) => snap === 0 ? 0 : Math.ceil(val / snap) * snap;\n  const x = calc(pending_x, x_snap);\n  const y = calc(pending_y, y_snap);\n  return [x, y];\n};\nfunction get_handle_els(handle, node) {\n  if (!handle)\n    return [node];\n  if (is_HTMLElement(handle))\n    return [handle];\n  if (Array.isArray(handle))\n    return handle;\n  const handle_els = node.querySelectorAll(handle);\n  if (handle_els === null)\n    throw new Error(\n      \"Selector passed for `handle` option should be child of the element on which the action is applied\"\n    );\n  return Array.from(handle_els.values());\n}\nfunction get_cancel_elements(cancel, node) {\n  if (!cancel)\n    return [];\n  if (is_HTMLElement(cancel))\n    return [cancel];\n  if (Array.isArray(cancel))\n    return cancel;\n  const cancel_els = node.querySelectorAll(cancel);\n  if (cancel_els === null)\n    throw new Error(\n      \"Selector passed for `cancel` option should be child of the element on which the action is applied\"\n    );\n  return Array.from(cancel_els.values());\n}\nvar cancel_element_contains = (cancel_elements, drag_elements) => cancel_elements.some((cancelEl) => drag_elements.some((el) => cancelEl.contains(el)));\nfunction compute_bound_rect(bounds, rootNode) {\n  if (bounds === void 0)\n    return;\n  if (is_HTMLElement(bounds))\n    return bounds.getBoundingClientRect();\n  if (typeof bounds === \"object\") {\n    const { top = 0, left = 0, right = 0, bottom = 0 } = bounds;\n    const computed_right = window.innerWidth - right;\n    const computed_bottom = window.innerHeight - bottom;\n    return { top, right: computed_right, bottom: computed_bottom, left };\n  }\n  if (bounds === \"parent\")\n    return rootNode.parentNode.getBoundingClientRect();\n  const node = document.querySelector(bounds);\n  if (node === null)\n    throw new Error(\"The selector provided for bound doesn't exists in the document.\");\n  return node.getBoundingClientRect();\n}\nvar set_style = (el, style, value) => el.style.setProperty(style, value);\nvar is_HTMLElement = (obj) => obj instanceof HTMLElement;\n\n// src/index.ts\nvar draggable2 = draggable;\n//!THIS IS HACK, WE WANNA IMPORT THE TYPE WHEN THE ISSUE IS FIXED LATER\n\nexport { draggable2 as draggable };\n"],
  "mappings": "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",
  "names": []
}
